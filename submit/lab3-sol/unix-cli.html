<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Unix  Command  Line  Introduction</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script type="text/javascript"
          src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js">
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github.min.css">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
</head>

<body class=umt-article>
    <nav id="course-nav">
      <ul>
      </ul>
    </nav>

    <div class="umt-content">
      <div><section data-level="h1"><h1>Unix  Command  Line  Introduction</h1><p><strong>Date</strong>: Feb 12
</p><p>This document first describes the aims of this lab.  It then provides
necessary background.  It then describes the exercises which need to be
performed.
</p><p>In the listings which follow, comments are any text extending from 
a <code>#</code> character to end-of-line.
</p><section data-level="h2"><h2>Aims</h2><p>The aim of this lab is to introduce you to the Unix command-line.  After
completing this lab, you should be familiar with the following topics:
</p><ul><li><p>Simple Unix commands like <code>ls</code>, <code>cat</code>, and <code>wc</code>.
</p></li><li><p>The typical syntax of Unix commands.
</p></li><li><p>The use of wildcards on the command-line.
</p></li><li><p>The standard I/O streams.
</p></li><li><p>How to redirect the standard I/O streams to files and commands.
</p></li><li><p>How to get help on a Unix system.
</p></li></ul></section><section data-level="h2"><h2>Background</h2><p>The Unix shell is a command-line program which allows users to interact with
a Unix system.  Even though we colloquially use the term <em>the Unix shell</em>,
there are many Unix shells with names like <code>sh</code>, <code>csh</code>, <code>bash</code>, <code>tcsh</code>, etc.
The first popular shell was <code>sh</code> written by Stephen Bourne.
</p><p>All information within a Unix system is stored within <em>files</em>.  As far as
Unix is concerned a <em>file</em> is nothing but an unstructured sequence of bytes.
Unlike other OS's, Unix itself does not require that the files have any kind
of record structure.  The structure of a file is dictated only by the
application programs which manipulate the file.
</p><p>The collection of files on a unix system is organized in a hierarchy of
<em>folders</em> or <em>directories</em>; i.e., a directory consists of a collection of
files and other directories.  The root directory of the entire hierarchy is
denoted as <code>/</code>.  Any Unix process always has a current directory denoted as
<code>.</code> (the character period), and can refer to the parent of the current
directory using <code>..</code> (two period characters).
</p><p>A file or directory <strong>name</strong> can consist of a sequence of any characters
other than <code>/</code> or the ASCII <code>NUL</code> character (  <code>'\0'</code> in C syntax).  A
<strong>pathname</strong> is a sequence of directory names, optionally followed by a
filename separated by <code>/</code> characters. If the pathname begins with a
<code>/</code>, then it is an absolute pathname, otherwise it is a relative
pathname interpreted relative to the <em>current directory</em>.
</p><p>Example names:
</p><pre>  /bin/ls               #an absolute path name
  bin/hello             #a relative path name
  ./hello               #the file hello in the current directory
  ../hello              #the file hello in the parent of the current directory
</pre><p>A shell <strong>command</strong> consists of a <em>command-name</em> followed by <em>options</em>
and <em>arguments</em> separated by blanks.  The arguments specify the
information needed by the command whereas the options control how the
command works.  Usually, options begin with a <code>-</code> or <code>--</code>, but since
each command defines the exact syntax of options and arguments there
can be subtle differences in the syntax of options between different
commands.
</p><p>Example commands:
</p><pre class="hljs language-sh">$ ls -l                 #list the contents of a directory 
                        #in a long format (option -l).
$ ls dir                #list contents of directory
                        #dir (an argument).
$ ls -l dir             #list contents of dir (argument)
                        #in long format (option -l).
$ ls -d -l dir          #list information about dir (not contents)
$ ls --directory -l dir #long option
                        #--directory equivalent to -d above
$ ls -dl dir            #like -d -l;
                        #many commands allow short options to be combined
</pre><p>To get help for a command, use the <code>man</code> command.  Example, <code>man ls</code>.
</p></section><section data-level="h2"><h2>Starting up</h2><p>Get started with this lab by using the
 <a href="../../misc/work-directions/work-directions.html#start">generic
startup directions</a> with <code>ASSGN=lab3</code>.
</p><p>Set up random files for this lab:
</p><pre class="hljs language-sh">$ cd ~/i220/submit/lab3-sol
$ ~/c220/labs/lab3/extras/gen-data.sh
</pre><p>This will create random data files within <code>lab3-sol/data</code>.
</p></section><section data-level="h2"><h2>Exercise 1: Some Basic Commands</h2><p>You should be in the <code>lab3-sol</code> directory.  Type the following commands:
</p><pre class="hljs language-sh">$ ls         #short contents of current directory sorted by name
$ ls -t      #sorted by modification time instead of name (newest first)
$ ls -l      #long contents of current directory: the columns will
             #show permissions (r = read allowed; w = write allowed;
             #x = execute allowed, 3 groups for owner, group and other; 
             #initial d for directories), owner name, group name, size in
             #bytes, last modification time, name.
$ ls -tl     #sort by last modification time instead of by name (newest first)
$ ls -l -gG  #long contents without owner (-g) or group (-G)

$ ls data      #show contents of data directory
$ ls -tl data  #show long contents of data sorted (descending) by last mod time
$ ls -l -gG data/h-9 #show long contents of data/h-9 sorted by name,
                     #omitting owner (-g) and group info (-G).
</pre><p>You can get further details on the <code>ls</code> command using <code>man ls</code>.
</p><p>Now come up with some of these commands on your own. 
</p><p>Type in commands for each of the following.  Once you are convinced
that a command <em>CMD</em> is working correctly, log the output for
submission using <em>CMD</em> <code>></code> <em>LOG_FILE</em> where <em>LOG_FILE</em> is the filename
mentioned within the <code>[...]</code> below.
</p><ol><li><p>The short <code>ls</code> contents of <code>data</code> (only the names), sorted by
    modification time (newest first) [<code>ex1-1.LOG</code>].
</p></li><li><p>The long <code>ls</code> contents of <code>data</code> without owner or group names,
    sorted by name.  [<code>ex1-2.LOG</code>].
</p></li><li><p>The short <code>ls</code> contents of <code>data/d-6</code>, sorted by name.
    [<code>ex1-3.LOG</code>]
</p></li><li><p>The long <code>ls</code> contents of <code>data/l-18</code> without owner or group
    names, sorted in decending order of modification time.
    [<code>ex1-4.LOG</code>]
</p></li></ol><p>Verify that you have not captured an <code>ls</code> listing containing your
login-id (which would break gradescope grading).  Run the command
<code>grep $USER *.LOG</code> and verify that it does not produce any output.
</p><p>To ensure that your captured <code>LOG</code> files are reasonable, ensure that
running <code>wc ex1*.LOG</code> results in the following output:
</p><pre>   6    6   27 ex1-1.LOG
   7   44  222 ex1-2.LOG
  70   70  765 ex1-3.LOG
  73  506 2879 ex1-4.LOG
 156  626 3893 total
</pre></section><section data-level="h2"><h2>Exercise 2: Wildcards</h2><p>The following characters are interpreted specially by the shell to allow 
specification of file-<em>globbing</em> patterns:
</p><dl><dt> <code>*</code></dt><dd><p>     matches any sequence of file-name characters (including the empty
     sequence).
</p></dd><dt> <code>?</code></dt><dd><p>     matches any single character.
</p></dd><dt> <code>[</code><em>XY ... Z</em><code>]</code></dt><dd><p>     matches any one of the characters <em>XY ... Z</em>.  For example, <code>[aeiou]</code>
     matches a vowel character.
</p></dd><dt> <code>[</code><em>X</em><code>-</code><em>Y</em><code>]</code></dt><dd><p>     match character <em>X</em> through <em>Y</em>. For example, <code>[0-9]</code> matches a digit.
</p></dd></dl><p>The special interpretation occurs only when there are files which match the
pattern.  To prevent the special interpretation, quote the special character
by preceeding with a backspace or by enclosing within single <code>'</code> or double <code>&quot;</code>
quotes.
</p><p>[If you are familiar with <em>regular expressions</em>, do not confuse
globbing-patterns with regular expressions.  Though there are some
similarities, they are really quite different].
</p><p>Type the following commands:
</p><pre class="hljs language-sh">$ ls data/c-15/*.java      #show paths of all java files in data/c-15
$ ls data/c-15/[a-m]*.java #all java files in data/c-15 with starting with a-m
$ ls data/c-15/?x[t-v]*	   #all files in data/c-15 with 2nd letter x, 3rd  t-v
$ ls data/*/*[28]*.java    #all java files in data subdirs with 2, 8 in name
</pre><p>Now type in the commands to list:
</p><ol><li><p>Paths of all the <code>.c</code> files in directory <code>data/z-12</code> having second
    letter <code>x</code>.  [<code>ex2-1.LOG</code>]
</p></li><li><p>Paths of all the files in <code>data/z-12</code> with 3 and 7 in name and
    extension starting with <code>j</code>. [<code>ex2-2.LOG</code>]
</p></li></ol><p>To ensure that your captured <code>LOG</code> files are reasonable, ensure that
running <code>wc ex2*.LOG</code> results in the following output:
</p><pre>  6   6 118 ex2-1.LOG
 19  19 418 ex2-2.LOG
 25  25 536 total
</pre></section><section data-level="h2"><h2>Exercise 3: Standard Streams and I/O Redirection</h2><p>Every process on a Unix system has access to 3 standard input-output
(I/O) streams:
</p><dl><dt> <strong>Standard input</strong></dt><dd><p>    The process can read its textual input data from this stream.  
</p></dd><dt> <strong>Standard output</strong></dt><dd><p>    The process can write its normal textual output to this stream.
</p></dd><dt> <strong>Standard error</strong></dt><dd><p>    The process can write its error messages to this stream.
</p></dd></dl><p>By default, all 3 streams refer to the terminal.  However, it is possible to
redirect the streams to files or commands.
</p><p>If a command is followed by a <code>></code> character followed by a filename,
then the standard output of the command is <strong>redirected</strong> to the file.
You have been using this feature in the preceding exercises to capture
the output of your commands into files which will be submitted.
</p><p>Within your <code>lab3-sol</code> directory:
</p><ol><li><p>Run <code>ls</code>.  You should see the original files as well as the <code>.LOG</code>
    files generated in your previous exercises.  Now run <code>ls >
    ls.log</code>.  No output should be produced on the terminal; instead
    the output should have been redirected to <code>ls.log</code>.
</p><p>    To see the contents of <code>ls.log</code>, do <code>cat ls.log</code>.  You will see
    that it contains <code>ls.log</code> in addition to the files originally in
    the directory.
</p><p>    You may have noticed that when you do not redirect the contents of
    the <code>ls</code> command, it lists the directory contents with multiple
    names per line.  However, when you looked at the contents of
    <code>ls.log</code> produced by the redirected <code>ls</code> command, it lists only
    one name per line.
</p><p>    [The <code>cat</code> command con<strong>cat</strong>enates the files specified by its
    command-line arguments onto standard output; if there are no files
    specified, then it merely copies standard input to standard
    output.  Do <code>man cat</code> for further information on the <code>cat</code>
    command]
</p></li><li><p>Try <code>cat >cat.log</code>.  There should be no output.  Type in the following
    two lines without any leading whitespace:
</p><pre>    Twas brillig,
    and the slithy toves
</pre><p>    followed by a <code>control-D</code> character.  Then type <code>cat cat.log</code> and
    you should see the above two lines displayed on the terminal (note
    that this is a handy trick when you happen to get onto a barely
    working computer which does not have a functioning text editor).
</p></li></ol><p>If a command is followed by <code>>></code> characters followed by a filename, then the
standard output of the command will be <strong>appended</strong> to the filename.
</p><p>Try <code>cat cat.log >>ls.log</code>.  You should see that <code>ls.log</code> now contains
the output of both redirections.
</p><p>If a command is followed by the <code>&lt;</code> character followed by a filename, then
the standard input of the command is redirected from filename.  
</p><p>Try <code>cat &lt;ls.log</code>; i.e., the <code>cat</code> command is run without any arguments,
hence it will copy its standard input to standard output.  Since the
standard input is being redirected from <code>ls.log</code>, this command should do
exactly the same as <code>cat ls.log</code> without the input redirection.
</p><p>Finally, if two command are separated by the <code>|</code> character, then the standard
output of the first command is fed into the standard input of the second
command.  The combined command is known as a <em>pipeline</em>.
</p><p>For example, <code>wc -l</code> will print out the number of lines on its
standard input (do <code>man wc</code> for other
options). So <code>cat ls.log | wc -l</code> will give you the number of lines
in <code>ls.log</code>.  Try <code>ls data/z-12/*.java | wc -l</code> to get a count of the
number of <code>.java</code> files in the <code>data/z-12</code> directory.
</p><p>Now type in the commands to achieve the following:
</p><ol><li><p>Run a command which initializes a <code>ex3-1.LOG</code> file with the number of <code>.c</code>
    files in all subdirectories of <code>data</code>
</p><p>    Then run a command which appends the paths of all <code>.c</code> files in all
    subdirectories of <code>data</code> to <code>ex3-1.LOG</code>.
</p></li><li><p>A command which captures all the paths in <code>data/z-12</code> transformed to
    uppercase in file <code>ex3-2.LOG</code>.
</p><p>    <strong>Hint</strong>: The command <code>tr a-z A-Z</code> will replace all lower-case
    letters in it standard input with upper-case letters in standard output.
    You can get further details on the <code>tr</code> command using <code>man tr</code>.
</p></li></ol><p>To ensure that your captured <code>LOG</code> files are reasonable, ensure that
running <code>wc ex3*.LOG</code> results in the following output:
</p><pre> 110  110 2110 ex3-1.LOG
  71   71  783 ex3-2.LOG
 181  181 2893 total
</pre></section><section data-level="h2"><h2>Exercise 4: Standard Streams in C</h2><p>Change over to the  <a href="lab3-sol/c-stdin-stdout">c-stdin-stdout</a>
directory.  It contains a trivial 
<a href="lab3-sol/c-stdin-stdout/Makefile">Makefile</a> and a simple C program 
<a href="lab3-sol/c-stdin-stdout/sum-ints.c">sum-ints.c</a> which sums pairs of integers read from either a file or
standard input.  It also contains a trivial
 <a href="lab3-sol/c-stdin-stdout/test1.in">test1.in</a> test data file.
</p><p>Study the code provided in 
<a href="lab3-sol/c-stdin-stdout/sum-ints.c">sum-ints.c.</a>  Use the Unix man pages to understand the library
functions which are used.  In particular, be sure to look at the man
pages for 
<a href="https://man7.org/linux/man-pages/man3/fopen.3.html">fopen(3),</a> 
<a href="https://man7.org/linux/man-pages/man3/strcmp.3.html">strcmp(3)</a> and the return value for
 <a href="https://man7.org/linux/man-pages/man3/fscanf.3p.html">fscanf().</a>
</p><p>Build the program using <code>make</code>.
</p><p>Note that the program requires the first argument to be a file
containing pairs of integers to be added.  However, if the first
argument is specified as <code>&quot;-&quot;</code> then it will read the input integers
from stdin.
</p><p>Run the program:
</p><pre class="hljs language-sh"># show a usage message
$ ./sum-ints 
usage: ./sum-ints IN_FILE [OUT_FILE]

# show contents of test data
$ cat test1.in 
3 5
3 -3

# sum pairs of ints from test1.in
$ ./sum-ints test1.in 
8
0

# sum pairs of ints from test1.in, write results to test1.out
$ ./sum-ints test1.in test1.out

# look at result file
$ cat test1.out 
8
0

# specify input file as - to read from stdin
$ ./sum-ints -
7 4
11
8 2
10
-3 5
2
# type ^D to indicate EOF

# read from stdin but write to test2.out file
$ ./sum-ints - test2.out
3 6
9 7
# type ^D to indicate EOF

# check results
$ cat test2.out
9
16
$
</pre><p>To test your understanding, do the following within the <code>c-stdin-stdout</code>
directory:
</p><ol><li><p>Without using a pipeline, use the <code>./sum-ints -</code> command in such a
    way so as to force the command to read the input integers from
    <code>test1.in</code> even though the first argument is specified as <code>-</code>.
</p><p>    Once you have the command working and assuming that it is the previous
    command run on your terminal, record it in <code>ex4-1.LOG</code> using
    the command <code>echo $(fc -ln -1) > ex4-1.LOG</code> which uses the
    shell command history to capture the previous command.
</p><p>    Verify that you have captured the correct command <code>cat ex4-1.LOG</code>.
</p></li><li><p>Modify <code>sum-ints.c</code> so that if <code>-</code> is specified for the second
    argument then the resuts are written to <code>stdout</code>.  Make sure to
    modify the initial comment in the file as well as the usage
    message.  
</p></li><li><p>Without using a pipeline, run your modified program using
    <code>./sum-ints - -</code> but set up the command in such a way that all
    input is read from <code>test1.in</code> and all output is written to
    <code>test1.out</code>.
</p><p>    Once the command is working, capture it as before using
    <code>echo $(fc -ln -1) > ex4-2.LOG</code> into file <code>ex4-2.LOG</code>.
</p><p>    Verify that you have captured the correct command <code>cat ex4-2.LOG</code>.
</p></li></ol></section><section data-level="h2"><h2>Winding Up</h2><p> <a href="../../misc/work-directions/work-directions.html#complete">Complete</a> and
 <a href="../../misc/work-directions/work-directions.html#submit">submit</a> this lab
using the previously provided
 <a href="../../misc/work-directions/work-directions.html">generic directions</a>.
</p></section><section data-level="h2"><h2>References</h2><p>Brian W. Kernighan, Rob Pike, <em>The Unix Programming Environment</em>,
Prentice-Hall, 1984.
</p><p>Web shell tutorials: do a google search on <code>bourne shell</code>.
</p><p>GNU bash Manual at
 <a href="http://www.gnu.org/software/bash/manual/html_node/index.html#Top">&lt;http://www.gnu.org/software/bash/manual/html_node/index.html#Top></a>.
</p><p>Mendel Cooper, <em>Advanced Bash-Scripting Guide</em> at
 <a href="http://tldp.org/LDP/abs/html/">&lt;http://tldp.org/LDP/abs/html/></a>.
</p><p>Rob Pike and Brian Kernighan,
 <a href="https://harmful.cat-v.org/cat-v/unix_prog_design.pdf">Program
design in the UNIX environment</a>, AT&amp;T Bell Laboratories Technical
Journal, October 1984, Vol. 63, No. 8, Pt 2.
</p></section></section></div>
    </div>

    <script type="module" src="../../assets/scripts/slide-controls.mjs"></script>
    <script type="module" src="../../assets/scripts/nav.mjs"></script> 
    <script type="module" src="../../assets/scripts/highlight.mjs"></script>
</body>
</html>

