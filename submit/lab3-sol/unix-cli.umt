      U n i x   C o m m a n d   L i n e   I n t r o d u c t i o n

*Date*: Feb 12

This document first describes the aims of this lab.  It then provides
necessary background.  It then describes the exercises which need to be
performed.

In the listings which follow, comments are any text extending from 
a `#` character to end-of-line.

                        Aims
                        ====

The aim of this lab is to introduce you to the Unix command-line.  After
completing this lab, you should be familiar with the following topics:

  + Simple Unix commands like `ls`, `cat`, and `wc`.

  + The typical syntax of Unix commands.

  + The use of wildcards on the command-line.

  + The standard I/O streams.

  + How to redirect the standard I/O streams to files and commands.

  + How to get help on a Unix system.


                         Background
                         ==========

The Unix shell is a command-line program which allows users to interact with
a Unix system.  Even though we colloquially use the term "the Unix shell",
there are many Unix shells with names like `sh`, `csh`, `bash`, `tcsh`, etc.
The first popular shell was `sh` written by Stephen Bourne.

All information within a Unix system is stored within "files".  As far as
Unix is concerned a "file" is nothing but an unstructured sequence of bytes.
Unlike other OS's, Unix itself does not require that the files have any kind
of record structure.  The structure of a file is dictated only by the
application programs which manipulate the file.

The collection of files on a unix system is organized in a hierarchy of
"folders" or "directories"; i.e., a directory consists of a collection of
files and other directories.  The root directory of the entire hierarchy is
denoted as `/`.  Any Unix process always has a current directory denoted as
`.` (the character period), and can refer to the parent of the current
directory using `..` (two period characters).

A file or directory *name* can consist of a sequence of any characters
other than `/` or the ASCII `NUL` character ( .- `'\0'` in C syntax).  A
*pathname* is a sequence of directory names, optionally followed by a
filename separated by `/` characters. If the pathname begins with a
`/`, then it is an absolute pathname, otherwise it is a relative
pathname interpreted relative to the "current directory".

Example names:

  ```
  /bin/ls               #an absolute path name
  bin/hello             #a relative path name
  ./hello               #the file hello in the current directory
  ../hello              #the file hello in the parent of the current directory
  ```

A shell *command* consists of a "command-name" followed by "options"
and "arguments" separated by blanks.  The arguments specify the
information needed by the command whereas the options control how the
command works.  Usually, options begin with a `-` or `--`, but since
each command defines the exact syntax of options and arguments there
can be subtle differences in the syntax of options between different
commands.

Example commands:

.code(lang=sh)
```
$ ls -l                 #list the contents of a directory 
                        #in a long format (option -l).
$ ls dir                #list contents of directory
                        #dir (an argument).
$ ls -l dir             #list contents of dir (argument)
                        #in long format (option -l).
$ ls -d -l dir          #list information about dir (not contents)
$ ls --directory -l dir #long option
                        #--directory equivalent to -d above
$ ls -dl dir            #like -d -l;
                        #many commands allow short options to be combined
```
    
To get help for a command, use the `man` command.  Example, `man ls`.




                        Starting up
                        ===========

Get started with this lab by using the
.<../../misc/work-directions/work-directions.html#start> "generic
startup directions" with `ASSGN=lab3`.

Set up random files for this lab:

.code(lang=sh)
~~~
$ cd ~/i220/submit/lab3-sol
$ ~/c220/labs/lab3/extras/gen-data.sh
~~~

This will create random data files within `lab3-sol/data`.

                Exercise 1: Some Basic Commands
                ===============================


You should be in the `lab3-sol` directory.  Type the following commands:


.code(lang=sh)
```
$ ls         #short contents of current directory sorted by name
$ ls -t      #sorted by modification time instead of name (newest first)
$ ls -l      #long contents of current directory: the columns will
             #show permissions (r = read allowed; w = write allowed;
             #x = execute allowed, 3 groups for owner, group and other; 
             #initial d for directories), owner name, group name, size in
             #bytes, last modification time, name.
$ ls -tl     #sort by last modification time instead of by name (newest first)
$ ls -l -gG  #long contents without owner (-g) or group (-G)

$ ls data      #show contents of data directory
$ ls -tl data  #show long contents of data sorted (descending) by last mod time
$ ls -l -gG data/h-9 #show long contents of data/h-9 sorted by name,
                     #omitting owner (-g) and group info (-G).
```

You can get further details on the `ls` command using `man ls`.

Now come up with some of these commands on your own. 

Type in commands for each of the following.  Once you are convinced
that a command "CMD" is working correctly, log the output for
submission using "CMD" `>` "LOG_FILE" where "LOG_FILE" is the filename
mentioned within the `[...]` below.

  # The short `ls` contents of `data` (only the names), sorted by
    modification time (newest first) [`ex1-1.LOG`].

  # The long `ls` contents of `data` without owner or group names,
    sorted by name.  [`ex1-2.LOG`].

  # The short `ls` contents of `data/d-6`, sorted by name.
    [`ex1-3.LOG`]

  # The long `ls` contents of `data/l-18` without owner or group
    names, sorted in decending order of modification time.
    [`ex1-4.LOG`]


Verify that you have not captured an `ls` listing containing your
login-id (which would break gradescope grading).  Run the command
`grep $USER *.LOG` and verify that it does not produce any output.

To ensure that your captured `LOG` files are reasonable, ensure that
running `wc ex1*.LOG` results in the following output:

```
   6    6   27 ex1-1.LOG
   7   44  222 ex1-2.LOG
  70   70  765 ex1-3.LOG
  73  506 2879 ex1-4.LOG
 156  626 3893 total
```

                        Exercise 2: Wildcards
                        =====================

The following characters are interpreted specially by the shell to allow 
specification of file-"globbing" patterns:

  : `*`:
     matches any sequence of file-name characters (including the empty
     sequence).

  : `?`:
     matches any single character.

  : `[`"XY ... Z"`]`:
     matches any one of the characters "XY ... Z".  For example, `[aeiou]`
     matches a vowel character.
     
  
  : `[`"X"`-`"Y"`]`:
     match character "X" through "Y". For example, `[0-9]` matches a digit.

The special interpretation occurs only when there are files which match the
pattern.  To prevent the special interpretation, quote the special character
by preceeding with a backspace or by enclosing within single `'` or double `"`
quotes.

[If you are familiar with "regular expressions", do not confuse
globbing-patterns with regular expressions.  Though there are some
similarities, they are really quite different].

Type the following commands:

.code(lang=sh)
```
$ ls data/c-15/*.java      #show paths of all java files in data/c-15
$ ls data/c-15/[a-m]*.java #all java files in data/c-15 with starting with a-m
$ ls data/c-15/?x[t-v]*	   #all files in data/c-15 with 2nd letter x, 3rd  t-v
$ ls data/*/*[28]*.java    #all java files in data subdirs with 2, 8 in name
```

Now type in the commands to list:

  # Paths of all the `.c` files in directory `data/z-12` having second
    letter `x`.  [`ex2-1.LOG`]

  # Paths of all the files in `data/z-12` with 3 and 7 in name and
    extension starting with `j`. [`ex2-2.LOG`]

To ensure that your captured `LOG` files are reasonable, ensure that
running `wc ex2*.LOG` results in the following output:

```
  6   6 118 ex2-1.LOG
 19  19 418 ex2-2.LOG
 25  25 536 total
```


                  Exercise 3: Standard Streams and I/O Redirection
                  ================================================

Every process on a Unix system has access to 3 standard input-output
(I/O) streams:

  : *Standard input*:
    The process can read its textual input data from this stream.  

  : *Standard output*:
    The process can write its normal textual output to this stream.

  : *Standard error*:
    The process can write its error messages to this stream.

By default, all 3 streams refer to the terminal.  However, it is possible to
redirect the streams to files or commands.

If a command is followed by a `>` character followed by a filename,
then the standard output of the command is *redirected* to the file.
You have been using this feature in the preceding exercises to capture
the output of your commands into files which will be submitted.

Within your `lab3-sol` directory:

  # Run `ls`.  You should see the original files as well as the `.LOG`
    files generated in your previous exercises.  Now run `ls >
    ls.log`.  No output should be produced on the terminal; instead
    the output should have been redirected to `ls.log`.

    To see the contents of `ls.log`, do `cat ls.log`.  You will see
    that it contains `ls.log` in addition to the files originally in
    the directory.

    You may have noticed that when you do not redirect the contents of
    the `ls` command, it lists the directory contents with multiple
    names per line.  However, when you looked at the contents of
    `ls.log` produced by the redirected `ls` command, it lists only
    one name per line.

    [The `cat` command con*cat*enates the files specified by its
    command-line arguments onto standard output; if there are no files
    specified, then it merely copies standard input to standard
    output.  Do `man cat` for further information on the `cat`
    command]

  # Try `cat >cat.log`.  There should be no output.  Type in the following
    two lines without any leading whitespace:

    ```
    Twas brillig,
    and the slithy toves
    ```

    followed by a `control-D` character.  Then type `cat cat.log` and
    you should see the above two lines displayed on the terminal (note
    that this is a handy trick when you happen to get onto a barely
    working computer which does not have a functioning text editor).

If a command is followed by `>>` characters followed by a filename, then the
standard output of the command will be *appended* to the filename.

Try `cat cat.log >>ls.log`.  You should see that `ls.log` now contains
the output of both redirections.

If a command is followed by the `<` character followed by a filename, then
the standard input of the command is redirected from filename.  

Try `cat <ls.log`; i.e., the `cat` command is run without any arguments,
hence it will copy its standard input to standard output.  Since the
standard input is being redirected from `ls.log`, this command should do
exactly the same as `cat ls.log` without the input redirection.

Finally, if two command are separated by the `|` character, then the standard
output of the first command is fed into the standard input of the second
command.  The combined command is known as a "pipeline".

For example, `wc -l` will print out the number of lines on its
standard input (do `man wc` for other
options). So `cat ls.log | wc -l` will give you the number of lines
in `ls.log`.  Try `ls data/z-12/*.java | wc -l` to get a count of the
number of `.java` files in the `data/z-12` directory.

Now type in the commands to achieve the following:

  # Run a command which initializes a `ex3-1.LOG` file with the number of `.c`
    files in all subdirectories of `data`

    Then run a command which appends the paths of all `.c` files in all
    subdirectories of `data` to `ex3-1.LOG`.
    

  # A command which captures all the paths in `data/z-12` transformed to
    uppercase in file `ex3-2.LOG`.

    *Hint*: The command `tr a-z A-Z` will replace all lower-case
    letters in it standard input with upper-case letters in standard output.
    You can get further details on the `tr` command using `man tr`.

To ensure that your captured `LOG` files are reasonable, ensure that
running `wc ex3*.LOG` results in the following output:

```
 110  110 2110 ex3-1.LOG
  71   71  783 ex3-2.LOG
 181  181 2893 total
```


                  Exercise 4: Standard Streams in C
                  =================================

Change over to the .<lab3-sol/c-stdin-stdout> c-stdin-stdout
directory.  It contains a trivial .<lab3-sol/c-stdin-stdout/Makefile>
Makefile and a simple C program .<lab3-sol/c-stdin-stdout/sum-ints.c>
sum-ints.c which sums pairs of integers read from either a file or
standard input.  It also contains a trivial
.<lab3-sol/c-stdin-stdout/test1.in> test1.in test data file.

Study the code provided in .<lab3-sol/c-stdin-stdout/sum-ints.c>
sum-ints.c.  Use the Unix man pages to understand the library
functions which are used.  In particular, be sure to look at the man
pages for .<https://man7.org/linux/man-pages/man3/fopen.3.html>
fopen(3), .<https://man7.org/linux/man-pages/man3/strcmp.3.html>
strcmp(3) and the return value for
.<https://man7.org/linux/man-pages/man3/fscanf.3p.html> fscanf().

Build the program using `make`.

Note that the program requires the first argument to be a file
containing pairs of integers to be added.  However, if the first
argument is specified as `"-"` then it will read the input integers
from stdin.

Run the program:

.code(lang=sh)
```
# show a usage message
$ ./sum-ints 
usage: ./sum-ints IN_FILE [OUT_FILE]

# show contents of test data
$ cat test1.in 
3 5
3 -3

# sum pairs of ints from test1.in
$ ./sum-ints test1.in 
8
0

# sum pairs of ints from test1.in, write results to test1.out
$ ./sum-ints test1.in test1.out

# look at result file
$ cat test1.out 
8
0

# specify input file as - to read from stdin
$ ./sum-ints -
7 4
11
8 2
10
-3 5
2
# type ^D to indicate EOF

# read from stdin but write to test2.out file
$ ./sum-ints - test2.out
3 6
9 7
# type ^D to indicate EOF

# check results
$ cat test2.out
9
16
$
```

To test your understanding, do the following within the `c-stdin-stdout`
directory:

  # Without using a pipeline, use the `./sum-ints -` command in such a
    way so as to force the command to read the input integers from
    `test1.in` even though the first argument is specified as `-`.

    Once you have the command working and assuming that it is the previous
    command run on your terminal, record it in `ex4-1.LOG` using
    the command `echo $(fc -ln -1) > ex4-1.LOG` which uses the
    shell command history to capture the previous command.

    Verify that you have captured the correct command `cat ex4-1.LOG`.

  # Modify `sum-ints.c` so that if `-` is specified for the second
    argument then the resuts are written to `stdout`.  Make sure to
    modify the initial comment in the file as well as the usage
    message.  

  # Without using a pipeline, run your modified program using
    `./sum-ints - -` but set up the command in such a way that all
    input is read from `test1.in` and all output is written to
    `test1.out`.

    Once the command is working, capture it as before using
    `echo $(fc -ln -1) > ex4-2.LOG` into file `ex4-2.LOG`.

    Verify that you have captured the correct command `cat ex4-2.LOG`.

                        Winding Up
                        ==========

.<../../misc/work-directions/work-directions.html#complete> Complete and
.<../../misc/work-directions/work-directions.html#submit> submit this lab
using the previously provided
.<../../misc/work-directions/work-directions.html> "generic directions".

                            References
                            ==========

Brian W. Kernighan, Rob Pike, "The Unix Programming Environment",
Prentice-Hall, 1984.

Web shell tutorials: do a google search on `bourne shell`.

GNU bash Manual at
.<http://www.gnu.org/software/bash/manual/html_node/index.html#Top> "".

Mendel Cooper, "Advanced Bash-Scripting Guide" at
.<http://tldp.org/LDP/abs/html/> "".

Rob Pike and Brian Kernighan,
.<https://harmful.cat-v.org/cat-v/unix_prog_design.pdf> "Program
design in the UNIX environment", AT&T Bell Laboratories Technical
Journal, October 1984, Vol. 63, No. 8, Pt 2.
